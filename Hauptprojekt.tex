\documentclass{llncs}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{graphicx}

\usepackage{url}
\usepackage{natbib}


\title{Hauptprojekt}
\author{Alexander Piehl\\\email{alexander.piehl@haw-hamburg.de}
\institute{Hamburg University of Applied Sciences,\\Dept. Computer Science, \\ Berliner Tor 7\\ 20099 Hamburg, Germany\\}}

\begin{document}
\maketitle
\section{Einleitung}
\nocite{*}
\section{REST}
REST ist ein Architekturstil für verteilte Systeme. Die Abkürzung REST  steht für Representational State Transfer \cite{chakrabarti2009test}.
Erstmals wurde REST 2000 von Roy Fielding vorgestellt \citep{kao2013performance}.
Die Rest-Architektur wird häufig für Client-Server Anwendungen verwendet. 
Dabei ist REST zurzeit sehr belie bbei der  Entwicklung von Webservices, da REST Webservices wohl nicht nur leichter zu implementieren sind, sondern auch einfacher zu skalieren sind. \cite{chakrabarti2009test}. 
Unter Anderem aus diesen Gründen stellten Google, Facebook und Yahoo ihre Services von SOAP auf REST um \cite{rodriguez2008restful, navas2014rest}.

REST basiert dabei auf Resource Oriented Architecture, kurz ROA \citep{chakrabarti2009test}. Dies bedeutet, dass jede wichtige Information als Ressource zur Verfügung stehen muss \cite{porres2011modeling}.
Die Zugänglichkeit zu der Ressource muss über eine eindeutige URI gegeben sein. Die Ressourcen sollen zusätzlich über verschiedene Methoden manipuliert werden können. Es müssen mindestens die sogenannten CRUD-Operatoren zur Verfügung stehen. CRUD steht für Create, Read, Update und Delete und beschreibt die grundsätzlichen Daten Operationen. Bei Rest werden dafür die standardisierten HTTP-Methoden verwendet, welche im Standard RFC 2616 definiert wurden sind \citep{kao2013performance}. In der Tabelle 1 werden die Beziehung zwischen den CRUD Operatoren und den HTTP Operatoren dargestellt.

\begin{table}[]
\centering
\label{CRUD_HTTP_Methods}
\begin{tabular}{|c|l|p{4cm}|p{4cm}|}
\hline
\multicolumn{1}{|l|}{CRUD-Operation} & HTTP-Methode \\ \hline
Create & POST  \\ \hline
Read & GET \\ \hline
Update & PUT \\ \hline
Delete & DELETE \\ \hline
\end{tabular}
\caption{Beziehung CRUD und HTTP Operatoren \cite{reza2010framework}}
\end{table}

Neben den CRUD-Operatoren können noch weitere HTTP-Methoden zur Verfügung stehen, wie z.B. HEAD und OPTIONS \cite{porres2011modeling}.

Die jeweiligen Aufrufe müssen Zustandslos erfolgen \cite{reza2010framework, porres2011modeling, kao2013performance}. Im Detail heißt dies, dass der Webservices keine Informationen über den Zustand seiner einzelnen Clients speichert. Sollten Informationen über den Zustand notwendig sein, müssen die Clients die Informationen mitgeben. Dahingehend ist es auch mit REST möglich kompliziertere Programmzustände abzubilden \cite{porres2011modeling}.

Die jeweiligen Nachrichten können in verschiedene Formate vorliegen \cite{reza2010framework}. Sehr häufig werden XML oder JSON oder beide Formate für die Nachrichten verwendet. Eine Vorschrift existiert nicht.

Zusammenfassend lässt sich REST in vier Grundprinzipien zusammenfassen \citep{porres2011modeling}: 

\begin{itemize}
\item \textbf{Addressability: } Jede wichtige Informationen muss als Ressource vorliegen und über eine eindeutige URI erreichbar sein.
\item \textbf{Connectedness: } Die Repräsentation der Ressourcen ist getrennt von den Ressourcen. Dies bedeutet Ressourcen können in verschiedenen Formate vorliegen, wie JSON und XML.
\item \textbf{Uniform Interface: } Auf die Ressourcen wird nur über standardisierten HTTP-Methoden zugegriffen.
\item \textbf{Statelessnes: } Jede Kommunikation erfolgt Zustandslos.
\end{itemize}

Webservices, welche die vier Grundprinzipien einhalten, bekommen häufig den Beinamen RESTful \citep{porres2011modeling}. Der Begriff RESTful ist jedoch nicht eindeutig definiert.  

\subsection{Besonderheiten beim Testen ?}
\section{Consumer Driven Contract Test}

\begin{itemize}
\item Erklärung Consumer Driven Ansatz
\begin{itemize}
\item Nutzer einer Schnittstelle definiert den Contract
\item Da der Nutzer wohl besser weiß, was er nutzen möchte und was nicht
\item Service Provider können nur erahnen
\item Vorteile es ist klar definiert, was der Service nutzen soll. Daher kann er so schlank wie möglich implementiert werden
\item Vorteile dazu gibt es einen feinjörnigen Einblick und schnelles Feedback für das planen von Änderungen. Ergänzend dazu können gezielt einzelnen Consumer angesprochen werden.
\item Aufgrundlage der Consumer Verträge wird der Service erstellt
\end{itemize}
\item Erläuterung Consumer Driven Contract Test
\begin{itemize}
\item Tool PACT
\item Consumer definiert seine Anfrage und die zu erwarteten Antworten, samit UNIT-Test
\item Implmentierung im Consumer
\item Beim Ausführen dieser Tests wird ein Server gestartet, der mit den entsprechenden Antworten auf die Anfragen reagiert
\item Dabei wird ein File erstellt, welches die Aufrufe und Antworten enthält
\item mit diesem File wird nun der Service Provider getestet
\item Antwortet er auf die Anfragen korrekt, wie es im File beschrieben ist

\end{itemize}
\end{itemize}

\subsection{Warum Consumer Driven Contract Test}
Bei dem Ansatz Consumer-Driven Contracts werden die Schnittstellen bzw. die Verträge aus der Sicht des Clients/Consumers definiert. Dabei spielt es keine Rolle, ob es nur einen Cosumer oder mehrere existieren. Die jeweiligen Anfragen und gewünschten Antworten werden notiert und auf Grundlage dieser Informationen wird der Service implementiert.

Wie sich aus der generellen Beschreibung dieses Ansatzes ableiten lässt, funktioniert der Ansatz nur, wenn sowohl die Consumer wie der Service neu implementiert werden. Bei bestehenden Anwendungen könnte dieser Verfahren dafür genutzt werden, um zu überprüfen, ob der Service unötige Schnittstellen anbietet.

Auf der Basis dieses Konzeptes setzen die Consumer Driven Contract Tests auf. Ein Tool, welches Consumer Driven Contract Tests unterstützt ist PACT. PACT ist ein Open-Source Tool.
\begin{itemize}
\item Vorteile bei Änderungen im Service kann sofort wieder gegen die Datei getestet werden, um zu prüfen, ob alle Consumer noch korrekt funktionieren
\item übersicht, was die Consumer Anfragen
\item sachnelles Feedback
\item wissen, ob Änderung zu ungewollten Fehlern
\item wissen, welche consumer aktualisiert werden müssen
\item MARS System, welches regelmäßig angepoasst wird
\item Architektur, welche Fokus auf des Netzwerk hat
\item Fehler wegen Schnittstelle problematisch
\end{itemize}
Was verspricht man sich davon?
Verbindung zu MARS - System im Wandel

\subsection{Implementierung}

\subsection{Einbindung in MARS}
\begin{itemize}
\item Aussuchen eines Services und Consumers
\item Aufrufen herausfinden via Browser und Postman
\item Testen der Aufrufe via Postman, um festzustellen das sie funktionieren und koirrekt sind
\item Aktueller Stand als korrekt anzusehen und Soll-Zustand
\item Implementierung des Consumers
\end{itemize}
\subsection{Fazit}
\begin{itemize}
\item Erklärung
\item Erläuterung zu der Verbindung mit Microservice
\item Normale Implementierung
\item Einbinden in Mars
\item Fazit
\end{itemize}
\subsection{Fazit}
\section{Ausblick Masterarbeit}

\bibliography{literatur}
\bibliographystyle{alpha}

\end{document}